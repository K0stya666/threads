## Документация по лабораторной работе 2: Потоки · Процессы · Асинхронность

*В этом документе представлены описания, результаты замеров и анализ для двух задач:*

* **Task 1:** Суммирование чисел от 1 до n различными подходами.
* **Task 2:** Параллельный парсинг веб‑страниц с сохранением в БД.

---

### Задача 1. Суммирование диапазона чисел

#### Файлы и реализации

* **threading\_prog.py**

  * Функция `sum_range(start, end, res, ind)` считает сумму чисел в диапазоне и сохраняет её в `res[ind]`.
  * `calculate_sum()` разбивает `[1, n]` на `k` потоков, ждёт их завершения и выводит общую сумму и время.

* **multiprocessing\_prog.py**

  * Функция `sum_range(args)` принимает `(start, end)` и возвращает сумму.
  * `calculate_sum()` формирует список диапазонов, создаёт `Pool(processes=k)`, выполняет `pool.map(sum_range, ranges)`, собирает результаты и выводит время.

* **async\_prog.py**

  * Функция `sum_range(start, end)` вычисляет сумму на уровне модуля.
  * `calculate_sum()` в `asyncio` создаёт `ProcessPoolExecutor(max_workers=k)`, запускает задачи через `loop.run_in_executor`, ждёт `await asyncio.gather()` и выводит результат и время.

* **parallel\_sum\_timer.py**

  * Импортирует все три подхода:

    * `run_threading()` из `threading_prog.py`,
    * `run_multiprocessing()` из `multiprocessing_prog.py`,
    * `run_asyncio()` из `async_prog.py`.
  * В `main()` последовательно измеряет и выводит время каждого метода и итоговую сравнительную таблицу.

#### Таблица результатов (Task 1)

| Метод            | Время выполнения, с | Проверочная сумма |
| ---------------- |---------------------| ----------------- |
| Threading        | 6.0870              | 5000000050000000  |
| Multiprocessing  | 2.5546              | 5000000050000000  |
| Asyncio+Executor | 2.6791              | 5000000050000000  |


#### Анализ Task 1

* **Threading:** скорость близка к однопоточному из‑за GIL.
* **Multiprocessing:** демонстрирует реальный параллелизм на ядрах, но тратит ресурсы на IPC и память.
* **Asyncio+Executor:** гибридный подход; уступает чистому `multiprocessing` из‑за оверхеда планировщика событий и передачи задач.

---

### Задача 2. Параллельный парсинг веб‑страниц

#### Файлы и реализации

* **threading\_parser.py**

  * Использует `ThreadedConnectionPool` из `psycopg2.pool`.
  * `parse_and_save(url, pool)` берёт соединение, делает `requests.get`, парсит `<title>`, сохраняет в БД, возвращает соединение.
  * `run_thread()` делит `url_list` на `k` частей, создаёт потоки, ждёт их завершения и возвращает время.

* **multiprocessing\_parser.py**

  * `parse_and_save(url)` открывает собственное соединение `psycopg2.connect`, выполняет HTTP-запрос и вставку в БД.
  * `run_mp()` создаёт `Pool(processes=k)` и запускает `pool.map(parse_and_save, url_list)`, возвращает время.

* **asyncio\_parser.py**

  * `parse_and_save(url, pool, session, sem)` ограничен семафором `k`, использует `aiohttp` и `asyncpg`.
  * `run_async()` создаёт пул `asyncpg.create_pool`, сессию `aiohttp.ClientSession()`, запускает `asyncio.gather` и возвращает время.

* **parallel\_parser\_timer.py**

  * Импортирует три функции: `run_thread`, `run_mp`, `run_async`.
  * В `main()` последовательно вызывает каждый метод, выводит время и итоговое сравнение.

#### Таблица результатов (Task 2)

| Метод           | Время выполнения, с |
| --------------- |---------------------|
| Threading       | 0.952               |
| Multiprocessing | 2.265               |
| Asyncio         | 0.724               |

#### Анализ Task 2

* **Threading:** эффективен при небольшом числе URL, но накладные расходы на I/O-блокировки.
* **Multiprocessing:** каждый процесс с отдельным соединением, хорош при изолированных задачах, но дороже на старте.
* **Asyncio:** лучший результат при большом числе запросов за счёт минимальных накладных расходов и асинхронного ввода‑вывода.

---